## פרויקט QUIC Connection

### תיאור הפרויקט

הפרויקט הזה הוא מימוש פשוט של פרוטוקול QUIC בפייתון באמצעות מודול asyncio. QUIC הוא פרוטוקול תחבורה מבוסס UDP המאפשר ביצועים מהירים יותר ויכולת הקמה מהירה של חיבורים מאשר TCP. הוא כולל יכולות מתקדמות כמו שליטה טובה יותר בריבוי חיבורים וביצועים טובים יותר על רשתות לא יציבות.

### מטרת הפרויקט

המטרה של הפרויקט היא להציג איך אפשר לממש פרוטוקול QUIC בצורה בסיסית ולבצע את הפעולות הבאות:

- פתיחת חיבור בין קליינט לשרת.
- שליחה וקבלה של נתונים דרך "מסגרות" (Frames) בתוך "מנות" (Packets).
- תמיכה במספר זרמי נתונים (Streams) במקביל בכל חיבור.
- סגירת חיבור בצורה בטוחה.

### קבצי הפרויקט

הפרויקט מחולק לכמה קבצים שכל אחד מהם מטפל בחלק אחר מהמימוש:

1. **QuicConnection.py**:

   - קובץ זה מכיל את מחלקת `QuicConnection` שאחראית על פתיחת חיבור, הקשבה לחיבורים נכנסים, ניהול התקשורת, ושליחה וקבלה של נתונים.

2. **Frame.py**:

   - מגדיר את מחלקת `Frame`, שמייצגת יחידת מידע (מסגרת) בפרוטוקול QUIC. המחלקה כוללת פונקציות להמרת המסגרת לבייטים ובחזרה.

3. **Packet.py**:

   - מגדיר את מחלקת `Packet`, שמייצגת קבוצה של מסגרות הנשלחות ביחד כמנה.

4. **Stream.py**:

   - מגדיר את מחלקת `Stream`, שמייצגת ערוץ נתונים אחד בתוך החיבור. זרמים מאפשרים העברת נתונים יעילה ומקבילה בתוך אותו חיבור QUIC.

5. **Server.py**:

   - קובץ זה מכיל את ההפעלה של שרת QUIC המשתמש ב-`QuicConnection` כדי להקשיב לחיבורים נכנסים ולטפל בהם.

6. **Client.py**:
   - קובץ זה מכיל את ההפעלה של קליינט QUIC המשתמש ב-`QuicConnection` כדי להתחבר לשרת ולשלוח ולקבל נתונים.

### מימוש

#### QuicConnection

מחלקה זו אחראית על ניהול החיבור בפרוטוקול QUIC. היא מבצעת פעולות של פתיחת חיבור לקליינט או לשרת, שליחה וקבלה של נתונים, ניהול זרמי נתונים, וסגירת חיבור.

##### פונקציות עיקריות:

- `connect`: פונקציה זו משמשת את הקליינט כדי להתחבר לשרת. היא מתחילה את תהליך ההתחברות ושולחת בקשת חיבור ראשונית לשרת.
- `listen`: פונקציה זו משמשת את השרת כדי להקשיב לחיבורים נכנסים. השרת תומך בחיבור אחד בכל פעם. הוא ממתין לבקשות חיבור ומנהל את התקשורת עם הקליינט.

- `send_packet`: שולחת מנות לכתובת היעד המוגדרת. המנות כוללות בתוכן מסגרות נתונים.

- `recv_packet`: מקבלת מנות שנשלחו לשרת ומטפלת בהן.

- `close`: סוגרת את החיבור בצורה בטוחה ומשחררת את המשאבים.

#### Frame

מחלקה זו מייצגת יחידת מידע בודדת (מסגרת) בפרוטוקול QUIC. המסגרות הן החלקים הקטנים ביותר של נתונים שעוברים בתוך חיבור QUIC.

##### פונקציות עיקריות:

- `to_bytes`: ממירה את המסגרת לפורמט של בייטים לשליחה ברשת.
- `from_bytes`: יוצרת אובייקט מסגרת מבייטים שהתקבלו.

#### Packet

מחלקה זו מייצגת מנה המכילה מספר מסגרות שנשלחות יחד.

##### פונקציות עיקריות:

- `to_bytes`: ממירה את המנה לבייטים לשליחה ברשת.
- `from_bytes`: יוצרת אובייקט מנה מבייטים שהתקבלו.

#### Stream

מחלקה זו מטפלת בזרם נתונים אחד בתוך חיבור QUIC. זרמים מאפשרים שליחה מקבילית של נתונים, כלומר, ניתן להעביר מספר קבצים או נתונים שונים באותו חיבור בודד. זה משפר את יעילות הפרוטוקול על פני TCP בכך שהוא מונע חסימות שנגרמות כאשר חלק מהמידע לא מגיע בזמן או כשיש איבוד מנות. זרמים מאפשרים להמשיך להעביר נתונים אחרים בזמן שחלק מהנתונים מתעכבים.

##### פונקציות עיקריות:

- `generate_frames`: מייצרת מסגרות מתוך קובץ נתונים או מקור נתונים אחר לשליחה.
- `get_next_frame`: מחזירה את המסגרת הבאה לשליחה מתוך זרם הנתונים.
- `receive_frame`: מקבלת מסגרת, מוסיפה אותה לנתונים שהתקבלו, ואם זו מסגרת סגירה (CLOSE) היא סוגרת את הזרם.
- `print_stats`: מדפיסה נתונים סטטיסטיים על הזרם, כגון כמות המסגרות והבתים שהתקבלו ונשלחו.

### יתרונות של QUIC על פני TCP

- **חיבור מהיר**: QUIC מאפשר להקים חיבור בצורה מהירה יותר מ-TCP הודות לשימוש ב-UDP והורדת הצורך במספר רב של פעימות ידיים (handshakes).
- **ריבוי זרמים**: ניתן לנהל מספר זרמים באותו חיבור מבלי להמתין לסיום של זרם אחד כדי להתחיל באחר.
- **התאוששות מהירה**: פרוטוקול QUIC מאפשר התאוששות מהירה יותר מאובדן מנות, בניגוד ל-TCP שבו כל החיבור עשוי להמתין במקרה של אובדן מנה.

### הפעלת הפרויקט

#### הפעלת השרת

כדי להפעיל את השרת, הרץ את הקובץ `Server.py`:

```bash
python Server.py [PORT]
```

השרת יתחיל להקשיב לחיבורים נכנסים על גבי הפורט שהתקבל.

#### הפעלת הקליינט

כדי להפעיל את הקליינט, הרץ את הקובץ `Client.py`:

```bash
python Client.py [HOST] [PORT] [NUMOFSTREAMS]
```

הקליינט ינסה להתחבר לשרת בכתובת ובפורט שהתקבלו ויתחיל את בקשת הזרמים.

### חלק ב: טסטים (בדיקות יחידה)

הטסטים נכתבים ב-`test_quic_connection.py` ומיועדים לבדוק את הפונקציות השונות במימוש פרוטוקול QUIC.

#### קובץ הבדיקות

1. **test_quic_connection.py**:
   - קובץ זה כולל מבחנים אוטומטיים (Unit Tests) שנכתבו באמצעות unittest כדי לבדוק את הפעולות השונות בפרויקט.

##### כיצד להריץ את הטסטים

כדי להריץ את הבדיקות, הרץ את הקובץ `test_quic_connection.py`:

```bash
python test_quic_connection.py
```

הבדיקות יבדקו את תפקוד הקוד במצבים שונים, כמו חיבור, שליחת מנות, קבלת מנות, וניהול זרמים.

#### מבנה הבדיקות

- `test_connect`: בודק שהקליינט יכול להתחבר לשרת בהצלחה.
- `test_handle_packet`: בודק טיפול בחבילות שהתקבלו בשרת.
- `test_send_packet_data`: בודק שליחת מנות מהקליינט לשרת.
- `test_stream_management`: בודק יצירה וניהול של זרמים.
- `test_close_connection`: בודק סגירת חיבור בצורה בטוחה.

### דרישות

- Python 3.7 ומעלה
- מודול asyncio

### התקנה

אין צורך בהתקנה מיוחדת. יש להוריד את הקוד ולהריץ את הסקריפטים בסביבת Python מתאימה.

### הערות נוספות

- פרויקט זה הוא מימוש בסיסי להדגמת עקרונות פרוטוקול QUIC ואינו מייצג מימוש מלא לכל היכולות של הפרוטוקול.
- וודא שהפורטים בהם אתה משתמש פתוחים ולא חסומים על ידי חומת אש או תוכנות אחרות.

### סיכום

פרויקט זה מספק מימוש פשוט וברור של פרוטוקול QUIC, יחד עם מבחני יחידה לוודא את תפקוד הקוד בצורה תקינה. המימוש מדגים את היתרונות של QUIC על פני TCP וכולל ניהול מתקדם של חיבורים וזרמים.

---
